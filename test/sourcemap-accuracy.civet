import { compile } from '../source/main.civet'
import assert from 'assert'
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { SourceMapConsumer } from 'source-map'
import { TraceMap, originalPositionFor as jridgewellOriginalPositionFor, LEAST_UPPER_BOUND } from '@jridgewell/trace-mapping'

// Define __dirname for ES modules
__filename := fileURLToPath(import.meta.url)
__dirname := path.dirname(__filename)

// Configuration for which library to use for testing
testWithLibrary := 'source-map' // Can be 'source-map' or 'jridgewell'

// Generate log file path based on chosen library
logFilePath := path.join(__dirname, `sourcemap-accuracy-${testWithLibrary}.log`)

// Helper to clear and append to log file
clearLog := () -> fs.writeFileSync(logFilePath, '', 'utf8')
appendToLog := (content: string) -> fs.appendFileSync(logFilePath, content, 'utf8')

interface TokenTest {
  tokenDescription: string // For logging, e.g., "data in for loop"
  
  // ---- Location of the token in the GENERATED TypeScript code ----
  generatedTSLine: number    // 1-based line number in the generated TS
  generatedTSColumn: number  // 0-based column number for the start of the token in TS

  // ---- Expected location in the ORIGINAL Civet code ----
  expectedOriginalCivetLine: number   // 1-based
  expectedOriginalCivetColumn: number // 0-based 
  
  // Optional: original token string if different from description, used for logging/verification
  originalCivetTokenString?: string 
}

// VLQ Decoding Utilities (adapted from Civet's sourcemap.civet for standalone use in this test script)
VLQ_SHIFT            := 5
VLQ_CONTINUATION_BIT := 1 << VLQ_SHIFT
VLQ_VALUE_MASK       := VLQ_CONTINUATION_BIT - 1

BASE64_CHARS_DECODER := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
vlqTableDecoder := new Uint8Array(128)
do
  i .= 0
  l .= vlqTableDecoder.length
  while i < l
    vlqTableDecoder[i] = 0xFF
    i++
  i = 0
  l = BASE64_CHARS_DECODER.length
  while i < l
    vlqTableDecoder[BASE64_CHARS_DECODER.charCodeAt(i)] = i
    i++

decodeSingleVLQSegment := (mappingSegment: string): number[] ->
  l .= mappingSegment.length
  result: number[] .= []
  currentMappingIndex .= 0

  // Scan over the input segment
  while currentMappingIndex < l
    shift .= 0
    vlq .= 0
    v .= 0

    while true
      if currentMappingIndex >= l
        throw new Error('Unexpected early end of VLQ mapping data in segment')
      
      char := mappingSegment.charCodeAt(currentMappingIndex)
      if (char & 0x7F) != char // Check if it's a valid ASCII char
        throw new Error(`Invalid mapping character code: ${char} in segment: ${mappingSegment}`)
      
      index := vlqTableDecoder[char & 0x7F]
      if (index is 0xFF)
        throw new Error(`Invalid mapping character: "${mappingSegment[currentMappingIndex]}" in segment: ${mappingSegment}`)
      
      currentMappingIndex++

      // Decode the byte
      vlq |= (index & VLQ_VALUE_MASK) << shift
      shift += VLQ_SHIFT

      // Stop if there's no continuation bit
      break if (index & VLQ_CONTINUATION_BIT) is 0

    // Recover the signed value
    if vlq & 1
      v = -(vlq >> 1)
    else
      v = vlq >> 1
    result.push v
  return result

describe "source map accuracy", ->
  before ->
    clearLog()
    appendToLog("Civet Sourcemap Accuracy Test Log\n===================================\n")
    appendToLog(`Testing with library: ${testWithLibrary}\n`)

  runScenario := async (scenarioName: string, civetCode: string, tokenTests: TokenTest[]) ->
    it scenarioName, async ->
      scenarioLogCollector: string[] .= []
      scenarioLogCollector.push(`\n\n\n--- BEGIN SCENARIO: ${scenarioName} ---`)
      scenarioLogCollector.push("Input Civet Code:")
      scenarioLogCollector.push(civetCode)

      sourceFilename := `${scenarioName.replace(/\\s+/g, '-')}.civet`

      result := compile(civetCode, {
        sync: true
        sourceMap: true
        js: false
        sources: sourceFilename
      })
      tsCode := result.code
      // # Provide source and out file names to populate `sources`
      outFilename := sourceFilename.replace('.civet', '.js')
      mapJson := result.sourceMap.json(sourceFilename, outFilename)

      scenarioLogCollector.push("\nGenerated TypeScript Code:")
      scenarioLogCollector.push(tsCode)
      scenarioLogCollector.push("\nGenerated Sourcemap JSON:")
      scenarioLogCollector.push(JSON.stringify(mapJson, null, 2))
      
      if (!mapJson.sources || mapJson.sources.length === 0 || mapJson.sources[0] === null) {
        mapJson.sources = [sourceFilename]; 
        mapJson.sourcesContent = [civetCode]; 
      } else if (!mapJson.sourcesContent || mapJson.sourcesContent.length === 0) {
        mapJson.sourcesContent = [civetCode];
      } else if (mapJson.sources && mapJson.sources[0] && mapJson.sources[0] !== sourceFilename && mapJson.sourcesContent && mapJson.sourcesContent[0] !== civetCode) {
        if (mapJson.sourcesContent[0] === civetCode) {
             scenarioLogCollector.push(`\nNOTE: Sourcemap source[0] is '${mapJson.sources[0]}', but test uses '${sourceFilename}'. Content matching assumed.`);
        }
      }

      appendToLog(scenarioLogCollector.join('\n') + '\n') 

      generatedTsLines := tsCode.split('\n');

      tokenVerificationLogs: string[] .= ["\n--- TOKEN MAPPING VERIFICATION ---"]
      scenarioFailureMessages: string[] .= []
      overallScenarioStatus .= "PASSED"

      // This warning remains useful: checks if the populated source filename is what we expect.
      if mapJson.sources && mapJson.sources.length > 0 && mapJson.sources[0] !== sourceFilename
          appendToLog(`\\n[TEST-WARNING] mapJson.sources[0] ('${mapJson.sources[0]}') does not match expected sourceFilename ('${sourceFilename}'). Check test setup or Civet output filename handling.\\n`)


      if testWithLibrary == 'source-map'
        await SourceMapConsumer.with mapJson, null, async (consumer) =>
          testToken := (testSpec: TokenTest): {status: string, details: string[], assertionMessage: string | undefined} ->
            tokenLog: string[] .= []
            tokenLog.push(`\n--- Testing Token: '${testSpec.tokenDescription}' (with source-map) ---`)
            
            assertionMessagePrefix := `Token '${testSpec.tokenDescription}' in scenario '${scenarioName}'`
            generatedTSPositionString .= `TS Line ${testSpec.generatedTSLine}, Col ${testSpec.generatedTSColumn}`
            mappedOriginalPositionString .= "N/A"
            expectedOriginalPositionString .= `Civet Line ${testSpec.expectedOriginalCivetLine}, Col ${testSpec.expectedOriginalCivetColumn}`
            currentTokenStatus .= "PASSED"
            currentTokenAssertionMessage: string | undefined .= undefined

            queriedTSLine_1based := testSpec.generatedTSLine
            queriedTSColumn_0based := testSpec.generatedTSColumn

            try
              if queriedTSLine_1based <= 0 || queriedTSLine_1based > generatedTsLines.length
                currentTokenStatus = `FAILED: Generated TS Line ${queriedTSLine_1based} is out of bounds (1 to ${generatedTsLines.length}).`
                currentTokenAssertionMessage = `${assertionMessagePrefix} specified generated TS line ${queriedTSLine_1based} is out of bounds.`
              else if queriedTSColumn_0based < 0 || queriedTSColumn_0based >= generatedTsLines[queriedTSLine_1based - 1].length
                currentTokenStatus = `FAILED: Generated TS Column ${queriedTSColumn_0based} is out of bounds for line ${queriedTSLine_1based} (length ${generatedTsLines[queriedTSLine_1based - 1].length}).`
                currentTokenAssertionMessage = `${assertionMessagePrefix} specified generated TS column ${queriedTSColumn_0based} is out of bounds for line ${queriedTSLine_1based}.`
              else
                orig := consumer.originalPositionFor({ line: queriedTSLine_1based, column: queriedTSColumn_0based })
                
                mappedOriginalPositionString = `Civet Line ${orig.line}, Col ${orig.column} (Source: ${orig.source || 'null/undefined'})`
                
                if (orig.source !== sourceFilename && orig.source !== null && orig.source !== undefined) {
                    tokenLog.push(`  WARNING: Mapped source ('${orig.source}') differs from expected ('${sourceFilename}').`)
                }
                if (orig.source === null || orig.source === undefined) {
                    tokenLog.push(`  CRITICAL: Mapped source is null or undefined. This often indicates a broken mapping.`)
                    if (currentTokenStatus === "PASSED") currentTokenStatus = "FAILED (Undefined Source)"
                    if (!currentTokenAssertionMessage) currentTokenAssertionMessage = `${assertionMessagePrefix} Mapped source is null or undefined.`
                }

                if (orig.line == null || orig.column == null) {
                  if (currentTokenStatus === "PASSED") currentTokenStatus = "FAILED (Null Original Position)"
                  if (!currentTokenAssertionMessage) currentTokenAssertionMessage = `${assertionMessagePrefix} Original line or column is null. Mapping: ${JSON.stringify(orig)}`
                } else {
                  if (orig.line !== testSpec.expectedOriginalCivetLine) {
                    if (currentTokenStatus === "PASSED") currentTokenStatus = `FAILED (Line Mismatch)`
                    else if (!currentTokenStatus.includes("Line Mismatch")) currentTokenStatus += " + Line Mismatch"
                    if (!currentTokenAssertionMessage) currentTokenAssertionMessage = `${assertionMessagePrefix} LINE MISMATCH. Expected: ${expectedOriginalPositionString}. Actual: ${mappedOriginalPositionString}.`
                  }
                  
                  if (orig.column !== testSpec.expectedOriginalCivetColumn) { 
                    if (currentTokenStatus === "PASSED") currentTokenStatus = `FAILED (Column Mismatch)`
                    else if (!currentTokenStatus.includes("Column Mismatch")) currentTokenStatus += " + Column Mismatch"
                    if (!currentTokenAssertionMessage) currentTokenAssertionMessage = `${assertionMessagePrefix} COLUMN MISMATCH. Expected: ${expectedOriginalPositionString}. Actual: ${mappedOriginalPositionString}.`
                  }
                }
            catch e: any
              currentTokenStatus = `FAILED (Unexpected Exception: ${e.message})`
              currentTokenAssertionMessage = `${assertionMessagePrefix} UNEXPECTED EXCEPTION: ${e.message}`
            
            finally
              tokenLog.push(`  Target Generated  : ${generatedTSPositionString}`)
              tokenLog.push(`  Expected Original : ${expectedOriginalPositionString}`)
              tokenLog.push(`  Actual Mapped     : ${mappedOriginalPositionString}`)
              tokenLog.push(`  Status            : ${currentTokenStatus}`)
              if (currentTokenAssertionMessage && currentTokenStatus !== "PASSED") {
                tokenLog.push(`  Failure Reason    : ${currentTokenAssertionMessage}`)
              }
              if (currentTokenStatus !== "PASSED") {
                const mappingLines = mapJson.mappings.split(';');
                const rawLineVLQ = mappingLines[queriedTSLine_1based - 1];
                tokenLog.push(`  Raw VLQ for TS Line ${queriedTSLine_1based}: ${rawLineVLQ}`);
                if (rawLineVLQ && rawLineVLQ.length > 0) {
                  tokenLog.push(`  Decoded Segments for TS Line ${queriedTSLine_1based}:`)
                  rawLineVLQ.split(',').forEach((segmentVLQ, idx) => {
                    try {
                      decodedSegment := decodeSingleVLQSegment(segmentVLQ)
                      tokenLog.push(`    - Segment ${idx + 1} ('${segmentVLQ}'): [${decodedSegment.join(', ')}]`)
                    } catch (decodeError: any) {
                      tokenLog.push(`    - Segment ${idx + 1} ('${segmentVLQ}'): FAILED TO DECODE (${decodeError.message})`)
                    }
                  })
                }
              }
              tokenLog.push(`--- End Token: '${testSpec.tokenDescription}' ---`)
              
            return { status: currentTokenStatus, details: tokenLog, assertionMessage: currentTokenAssertionMessage }

          for testSpec of tokenTests
              result: {status: string, details: string[], assertionMessage: string | undefined} .= testToken(testSpec)
              tokenVerificationLogs.push(result.details.join('\n'))
              if (result.status !== "PASSED")
                overallScenarioStatus = "FAILED"
                if (result.assertionMessage && !scenarioFailureMessages.includes(result.assertionMessage)) 
                  scenarioFailureMessages.push(result.assertionMessage)

      else if testWithLibrary == 'jridgewell'
        let traceMapInstance
        try
          console.log("Creating TraceMap instance with mapJson:", JSON.stringify(mapJson).substring(0, 200) + "...")
          traceMapInstance = new TraceMap(mapJson)
          console.log("TraceMap instance created successfully")
          
          // Test with a simple mapping to see if it works
          const testMapping = jridgewellOriginalPositionFor(traceMapInstance, { line: 1, column: 0, bias: LEAST_UPPER_BOUND })
          console.log("Test mapping result:", testMapping)
          
          // Replicate the testToken logic but using jridgewellOriginalPositionFor
          testTokenJR := (testSpec: TokenTest): {status: string, details: string[], assertionMessage: string | undefined} ->
            tokenLog: string[] .= []
            tokenLog.push(`\n--- Testing Token: '${testSpec.tokenDescription}' (with @jridgewell/trace-mapping) ---`)
            
            assertionMessagePrefix := `Token '${testSpec.tokenDescription}' in scenario '${scenarioName}'`
            generatedTSPositionString .= `TS Line ${testSpec.generatedTSLine}, Col ${testSpec.generatedTSColumn}`
            mappedOriginalPositionString .= "N/A"
            expectedOriginalPositionString .= `Civet Line ${testSpec.expectedOriginalCivetLine}, Col ${testSpec.expectedOriginalCivetColumn}`
            currentTokenStatus .= "PASSED"
            currentTokenAssertionMessage: string | undefined .= undefined

            queriedTSLine_1based := testSpec.generatedTSLine
            queriedTSColumn_0based := testSpec.generatedTSColumn
            
            try
              if queriedTSLine_1based <= 0 || queriedTSLine_1based > generatedTsLines.length
                currentTokenStatus = `FAILED: Generated TS Line ${queriedTSLine_1based} is out of bounds (1 to ${generatedTsLines.length}).`
                currentTokenAssertionMessage = `${assertionMessagePrefix} specified generated TS line ${queriedTSLine_1based} is out of bounds.`
              else if queriedTSColumn_0based < 0 || queriedTSColumn_0based >= generatedTsLines[queriedTSLine_1based - 1].length
                currentTokenStatus = `FAILED: Generated TS Column ${queriedTSColumn_0based} is out of bounds for line ${queriedTSLine_1based} (length ${generatedTsLines[queriedTSLine_1based - 1].length}).`
                currentTokenAssertionMessage = `${assertionMessagePrefix} specified generated TS column ${queriedTSColumn_0based} is out of bounds for line ${queriedTSLine_1based}.`
              else
                // @jridgewell/trace-mapping uses 1-based line and 0-based column for query
                orig := jridgewellOriginalPositionFor(traceMapInstance, { line: queriedTSLine_1based, column: queriedTSColumn_0based, bias: LEAST_UPPER_BOUND })
                
                // It returns 1-based line and 0-based column
                mappedOriginalPositionString = `Civet Line ${orig.line}, Col ${orig.column} (Source: ${orig.source || 'null/undefined'})`
                
                if (orig.source !== sourceFilename && orig.source !== null && orig.source !== undefined) {
                    tokenLog.push(`  WARNING: Mapped source ('${orig.source}') differs from expected ('${sourceFilename}').`)
                }
                if (orig.source === null || orig.source === undefined) {
                    tokenLog.push(`  CRITICAL: Mapped source is null or undefined. This often indicates a broken mapping.`)
                    if (currentTokenStatus === "PASSED") currentTokenStatus = "FAILED (Undefined Source)"
                    if (!currentTokenAssertionMessage) currentTokenAssertionMessage = `${assertionMessagePrefix} Mapped source is null or undefined.`
                }

                if (orig.line == null || orig.column == null) {
                  if (currentTokenStatus === "PASSED") currentTokenStatus = "FAILED (Null Original Position)"
                  if (!currentTokenAssertionMessage) currentTokenAssertionMessage = `${assertionMessagePrefix} Original line or column is null. Mapping: ${JSON.stringify(orig)}`
                } else {
                  if (orig.line !== testSpec.expectedOriginalCivetLine) {
                    if (currentTokenStatus === "PASSED") currentTokenStatus = `FAILED (Line Mismatch)`
                    else if (!currentTokenStatus.includes("Line Mismatch")) currentTokenStatus += " + Line Mismatch"
                    if (!currentTokenAssertionMessage) currentTokenAssertionMessage = `${assertionMessagePrefix} LINE MISMATCH. Expected: ${expectedOriginalPositionString}. Actual: ${mappedOriginalPositionString}.`
                  }
                  
                  // Compare 0-based columns
                  if (orig.column !== testSpec.expectedOriginalCivetColumn) { 
                    if (currentTokenStatus === "PASSED") currentTokenStatus = `FAILED (Column Mismatch)`
                    else if (!currentTokenStatus.includes("Column Mismatch")) currentTokenStatus += " + Column Mismatch"
                    if (!currentTokenAssertionMessage) currentTokenAssertionMessage = `${assertionMessagePrefix} COLUMN MISMATCH. Expected: ${expectedOriginalPositionString}. Actual: ${mappedOriginalPositionString}.`
                  }
                }
            catch e: any
              currentTokenStatus = `FAILED (Unexpected Exception: ${e.message})`
              currentTokenAssertionMessage = `${assertionMessagePrefix} UNEXPECTED EXCEPTION: ${e.message}`
          
            finally
              tokenLog.push(`  Target Generated  : ${generatedTSPositionString}`)
              tokenLog.push(`  Expected Original : ${expectedOriginalPositionString}`)
              tokenLog.push(`  Actual Mapped     : ${mappedOriginalPositionString}`)
              tokenLog.push(`  Status            : ${currentTokenStatus}`)
              if (currentTokenAssertionMessage && currentTokenStatus !== "PASSED") {
                tokenLog.push(`  Failure Reason    : ${currentTokenAssertionMessage}`)
              }
              if (currentTokenStatus !== "PASSED") {
                const mappingLines = mapJson.mappings.split(';');
                const rawLineVLQ = mappingLines[queriedTSLine_1based - 1];
                tokenLog.push(`  Raw VLQ for TS Line ${queriedTSLine_1based}: ${rawLineVLQ}`);
                if (rawLineVLQ && rawLineVLQ.length > 0) {
                  tokenLog.push(`  Decoded Segments for TS Line ${queriedTSLine_1based}:`)
                  rawLineVLQ.split(',').forEach((segmentVLQ, idx) => {
                    try {
                      decodedSegment := decodeSingleVLQSegment(segmentVLQ)
                      tokenLog.push(`    - Segment ${idx + 1} ('${segmentVLQ}'): [${decodedSegment.join(', ')}]`)
                    } catch (decodeError: any) {
                      tokenLog.push(`    - Segment ${idx + 1} ('${segmentVLQ}'): FAILED TO DECODE (${decodeError.message})`)
                    }
                  })
                }
              }
              tokenLog.push(`--- End Token: '${testSpec.tokenDescription}' ---`)
            
            return { status: currentTokenStatus, details: tokenLog, assertionMessage: currentTokenAssertionMessage }

          for testSpec of tokenTests
              result: {status: string, details: string[], assertionMessage: string | undefined} .= testTokenJR(testSpec)
              tokenVerificationLogs.push(result.details.join('\n'))
              if (result.status !== "PASSED")
                overallScenarioStatus = "FAILED"
                if (result.assertionMessage && !scenarioFailureMessages.includes(result.assertionMessage)) 
                  scenarioFailureMessages.push(result.assertionMessage)
        catch e: any
          overallScenarioStatus = "FAILED"
          scenarioFailureMessages.push(`Failed to create TraceMap instance: ${e.message}`)
      else
        throw new Error(`Unknown testWithLibrary value: ${testWithLibrary}`)

      // Log the determined status *before* token details
      statusMarker := if overallScenarioStatus == "PASSED" then "âœ…" else "ðŸš§"
      appendToLog(`\nSCENARIO OVERALL STATUS: ${statusMarker} ${overallScenarioStatus}\n`)

      appendToLog(tokenVerificationLogs.join('\n') + '\n') 
      appendToLog(`--- END SCENARIO: ${scenarioName} ---\n`)

      if (overallScenarioStatus !== "PASSED")
        assert.fail(`Scenario '${scenarioName}' failed. Check log for details. First few assertion messages: ${scenarioFailureMessages.slice(0,3).join('; ')}`)

  runScenario "Microtest3: inputPos and srcLine Synchronization",
    `// Civet L1
// Civet L2: tokenA then tokenB on the same line
first tokenA; second tokenB // Civet L3
// Civet L4
// Civet L5: call funcC
// Civet L6: call funcD on next line
call funcC
call funcD
`, // Expected TS for L3: first(tokenA); second(tokenB);
   // Expected TS for L6-L7: call(funcC); call(funcD);
    [
      // Test case for "first tokenA" on Civet L3
      // tokenA starts at original Civet L3 (0-idx 2), Col 6 (0-idx)
      { tokenDescription: 'L3 tokenA', generatedTSLine: 3, generatedTSColumn: 7, expectedOriginalCivetLine: 3, expectedOriginalCivetColumn: 6, originalCivetTokenString: 'tokenA' },
      // Test case for "second tokenB" on Civet L3
      // tokenB starts at original Civet L3 (0-idx 2), Col 21 (0-idx)
      { tokenDescription: 'L3 tokenB', generatedTSLine: 3, generatedTSColumn: 25, expectedOriginalCivetLine: 3, expectedOriginalCivetColumn: 21, originalCivetTokenString: 'tokenB' },

      // Test case for "call funcC" on Civet L6
      // Mapping for generated call(funcC) resolves to start of "call" keyword in original: Civet L6 (0-idx 5), Col 0 (0-idx)
      { tokenDescription: 'L6 funcC', generatedTSLine: 6, generatedTSColumn: 5, expectedOriginalCivetLine: 6, expectedOriginalCivetColumn: 0, originalCivetTokenString: 'funcC' },
      // Test case for "call funcD" on Civet L7
      // funcD is on the NEXT generated TS line.
      // Assuming 'call(funcD)' is generated. 'funcD' starts at TS Col 5 on that new line.
      { tokenDescription: 'L7 funcD', generatedTSLine: 7, generatedTSColumn: 5, expectedOriginalCivetLine: 7, expectedOriginalCivetColumn: 5, originalCivetTokenString: 'funcD' }
    ]
