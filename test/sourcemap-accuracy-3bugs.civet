import { compile } from '../source/main.civet'
import assert from 'assert'
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { TraceMap, originalPositionFor as jridgewellOriginalPositionFor, LEAST_UPPER_BOUND } from '@jridgewell/trace-mapping'

// Define __dirname for ES modules
__filename := fileURLToPath(import.meta.url)
__dirname := path.dirname(__filename)

// Generate log file path based on chosen library
logFilePath := path.join(__dirname, `sourcemap-accuracy-3bugs.log`)

// Helper to clear and append to log file
clearLog := () -> fs.writeFileSync(logFilePath, '', 'utf8')
appendToLog := (content: string) -> fs.appendFileSync(logFilePath, content, 'utf8')

interface TokenTest {
  tokenDescription: string // For logging, e.g., "data in for loop"
  
  // ---- Location of the token in the GENERATED TypeScript code ----
  generatedTSLine: number    // 1-based line number in the generated TS
  generatedTSColumn: number  // 0-based column number for the start of the token in TS

  // ---- Expected location in the ORIGINAL Civet code ----
  expectedOriginalCivetLine: number   // 1-based
  expectedOriginalCivetColumn: number // 0-based 
  
  // Optional: original token string if different from description, used for logging/verification
  originalCivetTokenString?: string 
}

// VLQ Decoding Utilities (adapted from Civet's sourcemap.civet for standalone use in this test script)
VLQ_SHIFT            := 5
VLQ_CONTINUATION_BIT := 1 << VLQ_SHIFT
VLQ_VALUE_MASK       := VLQ_CONTINUATION_BIT - 1

BASE64_CHARS_DECODER := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
vlqTableDecoder := new Uint8Array(128)
do
  i .= 0
  l .= vlqTableDecoder.length
  while i < l
    vlqTableDecoder[i] = 0xFF
    i++
  i = 0
  l = BASE64_CHARS_DECODER.length
  while i < l
    vlqTableDecoder[BASE64_CHARS_DECODER.charCodeAt(i)] = i
    i++

decodeSingleVLQSegment := (mappingSegment: string): number[] ->
  l .= mappingSegment.length
  result: number[] .= []
  currentMappingIndex .= 0

  // Scan over the input segment
  while currentMappingIndex < l
    shift .= 0
    vlq .= 0
    v .= 0

    while true
      if currentMappingIndex >= l
        throw new Error('Unexpected early end of VLQ mapping data in segment')
      
      char := mappingSegment.charCodeAt(currentMappingIndex)
      if (char & 0x7F) != char // Check if it's a valid ASCII char
        throw new Error(`Invalid mapping character code: ${char} in segment: ${mappingSegment}`)
      
      index := vlqTableDecoder[char & 0x7F]
      if (index is 0xFF)
        throw new Error(`Invalid mapping character: "${mappingSegment[currentMappingIndex]}" in segment: ${mappingSegment}`)
      
      currentMappingIndex++

      // Decode the byte
      vlq |= (index & VLQ_VALUE_MASK) << shift
      shift += VLQ_SHIFT

      // Stop if there's no continuation bit
      break if (index & VLQ_CONTINUATION_BIT) is 0

    // Recover the signed value
    if vlq & 1
      v = -(vlq >> 1)
    else
      v = vlq >> 1
    result.push v
  return result

export { decodeSingleVLQSegment }

describe "Civet Sourcemap Accuracy 3 Bugs", ->
  before ->
    clearLog()
    appendToLog("Civet Sourcemap Accuracy 3 Bugs Cases================================================\n")

  runScenario := async (scenarioName: string, civetCode: string, tokenTests: TokenTest[]) ->
    it scenarioName, async ->
      scenarioLogCollector: string[] .= []
      scenarioLogCollector.push(`\n\n\n--- BEGIN SCENARIO: ${scenarioName} ---`)
      scenarioLogCollector.push("Input Civet Code:")
      scenarioLogCollector.push(civetCode)

      sourceFilename := `${scenarioName.replace(/[^a-zA-Z0-9_]/g, '-')}.civet` // Ensure valid filename

      result := compile(civetCode, {
        sync: true,
        sourceMap: true,
        js: false,
        // sources: sourceFilename // Let compile populate sources based on filename
        filename: sourceFilename
      })
      tsCode := result.code
      outFilename := sourceFilename.replace('.civet', '.js')
      mapJson := result.sourceMap.json(sourceFilename, outFilename) // Pass filename for sources array

      scenarioLogCollector.push("\nGenerated TypeScript Code:")
      scenarioLogCollector.push(tsCode)
      scenarioLogCollector.push("\nGenerated Sourcemap JSON:")
      scenarioLogCollector.push(JSON.stringify(mapJson, null, 2))
      
      // Normalize sourcemap sources and content
      fixSources := () ->
        // Fix missing or empty sources array
        if !mapJson.sources?.length || !mapJson.sources[0]
          mapJson.sources = [sourceFilename]
        
        // Fix missing or empty sourcesContent
        if !mapJson.sourcesContent?.length || !mapJson.sourcesContent[0]
          mapJson.sourcesContent = [civetCode]
        // Handle source mismatch with content mismatch
        else if mapJson.sources[0] !== sourceFilename && mapJson.sourcesContent[0] !== civetCode
          if mapJson.sourcesContent[0] === civetCode
            scenarioLogCollector.push(`\nNOTE: Source filename mismatch but content matches. Using existing content.`)
          else
            scenarioLogCollector.push(`\nWARNING: Both source filename and content mismatch. Forcing correct values.`)
            mapJson.sources = [sourceFilename]
            mapJson.sourcesContent = [civetCode]
        // Handle correct source with wrong content
        else if mapJson.sources[0] === sourceFilename && mapJson.sourcesContent[0] !== civetCode
          scenarioLogCollector.push(`\nWARNING: Source filename correct but content mismatch. Fixing content.`)
          mapJson.sourcesContent = [civetCode]
      
      fixSources()

      appendToLog(scenarioLogCollector.join('\n') + '\n') 

      tsLines := tsCode.split('\n')
      logEntries: string[] .= ["\n--- TOKEN MAPPING VERIFICATION ---"]
      failMessages: string[] .= []
      scenarioStatus .= "PASSED" // Assume pass, will be set to FAILED on any token test failure

      if mapJson.sources && mapJson.sources.length > 0 && mapJson.sources[0] !== sourceFilename
          appendToLog(`[TEST-WARNING] mapJson.sources[0] ('${mapJson.sources[0]}') does not match expected sourceFilename ('${sourceFilename}'). This might indicate an issue in how Civet sets the source filename or how the test retrieves it.`)

      let traceMap: TraceMap | undefined
      try
        traceMap = new TraceMap(mapJson) // TraceMap constructor accepts the raw JSON object
        
        verifyToken := (token: TokenTest): {status: string, details: string[], message: string | undefined} ->
          log: string[] .= []
          log.push(`\n--- Testing Token: '${token.tokenDescription}' ---`)
          msgPrefix := `Token '${token.tokenDescription}' in scenario '${scenarioName}'`
          genPosition := `TS Line ${token.generatedTSLine}, Col ${token.generatedTSColumn}`
          let mappedPosition = "N/A"
          expectedPosition := `Civet Line ${token.expectedOriginalCivetLine}, Col ${token.expectedOriginalCivetColumn}`
          let status = "PASSED"
          let errorMsg: string | undefined = undefined

          tsLine := token.generatedTSLine    // 1-based
          tsColumn := token.generatedTSColumn  // 0-based
          
          try
            if tsLine <= 0 || tsLine > tsLines.length
              status = `FAILED: Gen. TS Line ${tsLine} out of bounds (1-${tsLines.length}).`
              errorMsg = `${msgPrefix} specified gen. TS line ${tsLine} out of bounds.`
            else if tsColumn < 0 || tsColumn >= tsLines[tsLine - 1].length
              status = `FAILED: Gen. TS Col ${tsColumn} out of bounds for line ${tsLine} (len ${tsLines[tsLine - 1].length}).`
              errorMsg = `${msgPrefix} specified gen. TS col ${tsColumn} out of bounds for line ${tsLine}.`
            else
              const orig = jridgewellOriginalPositionFor(traceMap!, { line: tsLine, column: tsColumn, bias: LEAST_UPPER_BOUND })
              mappedPosition = `Civet Line ${orig.line}, Col ${orig.column} (Source: ${orig.source || 'null/undefined'})`
              
              if (orig.source !== sourceFilename && orig.source !== null && orig.source !== undefined)
                log.push(`  WARNING: Mapped source ('${orig.source}') differs from expected ('${sourceFilename}').`)
              
              if (orig.source === null || orig.source === undefined)
                log.push(`  CRITICAL: Mapped source is null or undefined. This is the bug or related to it.`)
                if (status === "PASSED") status = "FAILED (Undefined Source)" // Mark as failed for PR
                if (!errorMsg) errorMsg = `${msgPrefix} Mapped source is null or undefined. Expected mapping to ${expectedPosition}.`
              
              if (orig.line == null || orig.column == null)
                if (status === "PASSED") status = "FAILED (Null Original Position)"
                if (!errorMsg) errorMsg = `${msgPrefix} Original line or column is null. Mapping: ${JSON.stringify(orig)}. Expected ${expectedPosition}.`
              else
                if (orig.line !== token.expectedOriginalCivetLine)
                  if (status === "PASSED") status = `FAILED (Line Mismatch)`
                  else if (!status.includes("Line Mismatch")) status += " + Line Mismatch"
                  if (!errorMsg) errorMsg = `${msgPrefix} LINE MISMATCH. Expected: ${expectedPosition}. Actual: ${mappedPosition}.`
                
                if (orig.column !== token.expectedOriginalCivetColumn)
                  if (status === "PASSED") status = `FAILED (Column Mismatch)`
                  else if (!status.includes("Column Mismatch")) status += " + Column Mismatch"
                  if (!errorMsg) errorMsg = `${msgPrefix} COLUMN MISMATCH. Expected: ${expectedPosition}. Actual: ${mappedPosition}.`
          catch e: any
            status = `FAILED (Exception: ${e.message})`
            errorMsg = `${msgPrefix} EXCEPTION: ${e.message}`
          finally
            log.push(`  Target Generated  : ${genPosition}`)
            log.push(`  Expected Original : ${expectedPosition}`)
            log.push(`  Actual Mapped     : ${mappedPosition}`)
            log.push(`  Status            : ${status}`)
            if (errorMsg && status !== "PASSED") {
              log.push(`  >>> Failure Reason: ${errorMsg}`)
            }
            if (status !== "PASSED") {
              const mappingLines = mapJson.mappings.split(';');
              const rawVLQ = (tsLine - 1 < mappingLines.length) ? mappingLines[tsLine - 1] : "[VLQ line out of bounds]"
              log.push(`  Raw VLQ for Gen. TS Line ${tsLine}: ${rawVLQ}`);
              if (rawVLQ && rawVLQ.length > 0 && rawVLQ !== "[VLQ line out of bounds]") {
                log.push(`  Decoded Segments for Gen. TS Line ${tsLine}:`)
                rawVLQ.split(',').forEach((segment: string, idx: number) => {
                  try {
                    decoded := decodeSingleVLQSegment(segment)
                    log.push(`    - Segment ${idx + 1} ('${segment}'): [${decoded.join(', ')}]`)
                  } catch (error: any) {
                    log.push(`    - Segment ${idx + 1} ('${segment}'): FAILED TO DECODE (${error.message})`)
                  }
                })
              }
            }
            log.push(`--- End Token: '${token.tokenDescription}' ---`)
          return { status, details: log, message: errorMsg }

        for testSpec of tokenTests
             result := verifyToken(testSpec)
             logEntries.push(result.details.join('\n'))
             if (result.status !== "PASSED")
               scenarioStatus = "FAILED"
               if (result.message && !failMessages.includes(result.message)) 
                 failMessages.push(result.message)
      catch e: any
         scenarioStatus = "FAILED"
         failMessages.push(`Failed to create TraceMap instance or run tests: ${e.message}`)

      statusMarker := if scenarioStatus == "PASSED" then "âœ…" else "ðŸš§"
      appendToLog(`\nSCENARIO OVERALL STATUS: ${statusMarker} ${scenarioStatus}\n`)
      appendToLog(logEntries.join('\n') + '\n') 
      appendToLog(`--- END SCENARIO: ${scenarioName} ---
`)

      // For PR, we want tests to fail if the bug is present.
      // The `expectedOriginal...` fields in TokenTest should reflect the *correct* desired mapping.
      // If `scenarioStatus` is "PASSED", it means Civet *correctly* mapped according to our expectations,
      // implying the bug might be fixed or the test doesn't target it well.
      // For this PR, we explicitly want to show failures, so if a test *passes*, we might note it, 
      // but the `assert.fail` should be for when `scenarioStatus` is FAILED (bug demonstrated).
      if (scenarioStatus !== "PASSED")
        assert.fail(`ðŸ”´ Scenario '${scenarioName}' FAILED, demonstrating an expected sourcemap bug. First failure: ${failMessages[0] || 'Unknown failure'}`)
      else
        console.warn(`ðŸŸ¢ Scenario '${scenarioName}' PASSED. This means the targeted bug might not be present or the test is not specific enough to trigger it with current Civet version.`)

  // --- Test Scenarios for --- //

  runScenario "Scenario_Bug1_MissingMap_If_IntermediateVar",
    `// Civet L1
condition := true // Civet L2
message := if condition // Civet L3
  intermediate := "AssignedInIf" // Civet L4: 'A' at col 17
  intermediate // Civet L5
else // Civet L6
  "ElseValue" // Civet L7
console.log message // Civet L8
`,
    [
      {
        tokenDescription: 'Bug1: Character "A" in "AssignedInIf"',
        generatedTSLine: 4,
        generatedTSColumn: 24, // 'A' in TS "AssignedInIf"
        expectedOriginalCivetLine: 4,
        expectedOriginalCivetColumn: 19 // 'A' in Civet "AssignedInIf"
      }
    ]
  
  runScenario "Scenario_Bug1_MissingMap_Else_IntermediateVar",
    `// Civet L1
condition := false // Civet L2
message := if condition // Civet L3
  "IfValue" // Civet L4
else // Civet L5
  intermediate := "AssignedInElse" // Civet L6: 'A' at col 17
  intermediate // Civet L7
console.log message // Civet L8
`,
    [
      { 
        tokenDescription: 'Bug1: Literal "AssignedInElse" in else branch via intermediate var',
        generatedTSLine: 6, // } else {
                             //   intermediate_1 = "AssignedInElse"; <-- TS Target Line
        generatedTSColumn: 17, // 'A' in "AssignedInElse" (corrected from 18)
        expectedOriginalCivetLine: 6, 
        expectedOriginalCivetColumn: 17 // Expected 'A' in "AssignedInElse"
      }
    ]

  runScenario "Scenario_Bug2_IncompleteMap_If_DirectAssign",
    `// Civet L1
condition := true // Civet L2
outputVar := "" // Civet L3
if condition // Civet L4
  outputVar := "InsideIf" // Civet L5: 'I' at col 14. Expected map to here, not col of '='.
`,
    [
      { 
        tokenDescription: 'Bug2: Literal "InsideIf" direct assign in if branch',
        generatedTSLine: 5, // if (condition) {
                             //   outputVar = "InsideIf"; <-- TS Target Line
        generatedTSColumn: 15, // 'I' in "InsideIf"
        expectedOriginalCivetLine: 5,
        expectedOriginalCivetColumn: 14 // Expected 'I' in "InsideIf"
      }
    ]
  
  runScenario "Scenario_Bug2_IncompleteMap_BracketedElse_DirectAssign",
    `// Civet L1
condition := false // Civet L2
outputVar := "" // Civet L3
if condition { // Civet L4
  outputVar := "ValueIf"
} else { // Civet L6
  outputVar := "ValueElse" // Civet L7: 'V' at col 14. Expected map to here.
}
`,
    [
      { 
        tokenDescription: 'Bug2: Literal "ValueElse" direct assign in bracketed else',
        generatedTSLine: 7, // } else {
                             //   outputVar = "ValueElse"; <-- TS Target Line
        generatedTSColumn: 15, // 'V' in "ValueElse"
        expectedOriginalCivetLine: 7,
        expectedOriginalCivetColumn: 14 // Expected 'V' in "ValueElse"
      }
    ]

  runScenario "Scenario_Bug3_MisalignedMap_IndentedElse_DirectAssign",
    `// Civet L1
condition := false // Civet L2
outputVar := "" // Civet L3
if condition // Civet L4
  outputVar := "ValueIf" // Civet L5
else // Civet L6
  outputVar := "ValueElseInIndented" // Civet L7: 'V' at col 14. Expected map to here, not to 'else' keyword.
`,
    [
      { 
        tokenDescription: 'Bug3: Literal "ValueElseInIndented" direct assign in indented else',
        generatedTSLine: 7, // } else {
                             //   outputVar = "ValueElseInIndented"; <-- TS Target Line
        generatedTSColumn: 15, // 'V' in "ValueElseInIndented"
        expectedOriginalCivetLine: 7, 
        expectedOriginalCivetColumn: 14 // Expected 'V' in "ValueElseInIndented"
      }
    ]
